#include <VoltageSense/VoltageSense.h>
#include "MockConfig.h"
#include "gtest/gtest.h"

using ::testing::Return;

class VoltageSenseTest : public ::testing::Test {
protected:
  VoltageSense voltageSense;
  int gpio = 13;
  int resolution = 4096;
  std::vector<double> coefficients = {0.0, 1.0}; // Mock coefficients
};

TEST_F(VoltageSenseTest, InitializesWithConfig) {
  ASSERT_TRUE(
      voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {1.0, 0.0}));
}

TEST_F(VoltageSenseTest, ReadsVoltage) {
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(2000));
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {0.0, 2.0});
  int voltage = voltageSense.readVoltage();
  ASSERT_EQ(voltage, 4000);
}

TEST_F(VoltageSenseTest, VoltageCalculation) {
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(2000));
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {0.0, 2.0});
  int voltage = voltageSense.readVoltage();
  ASSERT_EQ(voltage, 4000);
}

TEST_F(VoltageSenseTest, RealVoltageConversion) {
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(2000));
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {0.0, 2.0});
  int voltage = voltageSense.readVoltage();
  ASSERT_EQ(voltage, 4000);
}

TEST_F(VoltageSenseTest, InitializesWithCoefficients) {
  ASSERT_TRUE(
      voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, coefficients));
}

TEST_F(VoltageSenseTest, CoefficientsAreStoredCorrectly) {
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {0.5, 1.5});
  auto coeffs = voltageSense.getCoefficients();
  ASSERT_EQ(coeffs[0], 0.5);
  ASSERT_EQ(coeffs[1], 1.5);
}

TEST_F(VoltageSenseTest, HandlesMaxADCValue) {
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(resolution - 1)); // Max value according to resolution
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, coefficients);
  int voltage = voltageSense.readVoltage();
  int expectedVoltage =
      static_cast<int>(4095 * coefficients[1] + coefficients[0]);
  ASSERT_EQ(voltage, expectedVoltage);
}

TEST_F(VoltageSenseTest, HandlesMinADCValue) {
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(0)); // Min value
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, coefficients);
  int voltage = voltageSense.readVoltage();
  int expectedVoltage = static_cast<int>(0 * coefficients[1] + coefficients[0]);
  ASSERT_EQ(voltage, expectedVoltage);
}

TEST_F(VoltageSenseTest, InitializationFailsWithInsufficientCoefficients) {
  ASSERT_FALSE(
      voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {1.0}));
}

TEST_F(VoltageSenseTest, UpdatesCoefficientsAfterInitialization) {
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {1.0, 0.0});

  // First reading with original coefficients
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(2000));
  int originalVoltage = voltageSense.readVoltage();
  ASSERT_EQ(originalVoltage, 1);

  // Update coefficients
  std::vector<double> newCoefficients = {0.0, 2.0};
  voltageSense.updateCoefficients(newCoefficients);

  // Second reading with updated coefficients
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(2000));
  int updatedVoltage = voltageSense.readVoltage();
  ASSERT_EQ(updatedVoltage, 4000);
}

TEST_F(VoltageSenseTest, DoesNotUpdateCoefficientsWithInsufficientValues) {
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution, {1.0, 0.0});

  // Update coefficients with insufficient values
  std::vector<double> newCoefficients = {1.0};
  voltageSense.updateCoefficients(newCoefficients);

  // Reading should still be based on original coefficients
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(2000));
  int originalVoltage = voltageSense.readVoltage();
  ASSERT_EQ(originalVoltage, 1);
}

TEST_F(VoltageSenseTest, ReadsVoltageWithMultipleCoefficients) {
  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio))
      .WillOnce(testing::Return(2000));

  // Example coefficients for the polynomial: 0.0 + 1.0*x + 0.001*x^2
  std::vector<double> multipleCoefficients = {0.0, 1.0, 0.001};
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution,
                          multipleCoefficients);

  int voltage = voltageSense.readVoltage();

  int expectedVoltage =
      static_cast<int>(2000 * 1.0 + std::pow(2000, 2) * 0.001);
  ASSERT_EQ(voltage, expectedVoltage);
}

TEST_F(VoltageSenseTest, HandlesArbitraryNumberOfCoefficients) {
  std::vector<double> arbitraryCoefficients = {0.0, 1.0, 0.001, 0.000001};
  ASSERT_TRUE(voltageSense.initialize(hardwareInterfaceMock, gpio, resolution,
                                      arbitraryCoefficients));

  auto coeffs = voltageSense.getCoefficients();
  ASSERT_EQ(coeffs, arbitraryCoefficients);
}

TEST_F(VoltageSenseTest, PolynomialCalculationIndirectTest) {
  std::vector<double> coefficients = {0.0, 1.0, 0.001, 0.000001};
  voltageSense.initialize(hardwareInterfaceMock, gpio, resolution,
                          coefficients);

  int rawValue = 2000;
  double expectedValue = 0.0 + 2000 * 1.0 + std::pow(2000, 2) * 0.001 +
                         std::pow(2000, 3) * 0.000001;

  EXPECT_CALL(hardwareInterfaceMock, readADC(gpio)).WillOnce(Return(rawValue));

  int calculatedVoltage = voltageSense.readVoltage();
  ASSERT_NEAR(calculatedVoltage, static_cast<int>(expectedValue), 1e-9);
}
